// Generated by CoffeeScript 1.6.2
var CSSS, CSSValue, DocumentStyle, exports, _ref;

CSSValue = (function() {
  CSSValue.prototype.value = '';

  CSSValue.prototype.unit = null;

  CSSValue.returnWithUnit = true;

  function CSSValue(value, unit) {
    this.value = value;
    this.unit = unit;
  }

  CSSValue.prototype.valueOf = function() {
    return this.value;
  };

  CSSValue.prototype.toString = function() {
    if (this.unit) {
      return this.value + this.unit;
    } else {
      return this.value;
    }
  };

  return CSSValue;

})();

DocumentStyle = (function() {
  function DocumentStyle() {}

  DocumentStyle.prototype._import = [];

  DocumentStyle.prototype._tree = {};

  DocumentStyle.prototype._levels = [];

  DocumentStyle.prototype["eval"] = null;

  DocumentStyle.prototype._environments = {};

  DocumentStyle.prototype.__cssvalue__ = CSSValue;

  DocumentStyle.prototype.__init__ = function() {
    return this._levels = [];
  };

  DocumentStyle.prototype.__extend__ = function(obj) {
    var each, has;

    has = function(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    each = function(obj, iterator, context) {
      var i, key, l;

      if (obj == null) {
        return;
      }
      if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
        return obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        i = 0;
        l = obj.length;
        while (i < l) {
          if (iterator.call(context, obj[i], i, obj) === breaker) {
            return;
          }
          i++;
        }
      } else {
        for (key in obj) {
          if (_.has(obj, key) ? iterator.call(context, obj[key], key, obj) === breaker : void 0) {
            return;
          }
        }
      }
    };
    each(Array.prototype.slice.call(arguments, 1), function(source) {
      var prop, _results;

      if (source) {
        _results = [];
        for (prop in source) {
          _results.push(obj[prop] = source[prop]);
        }
        return _results;
      }
    });
    return obj;
  };

  DocumentStyle.prototype.object_to_css = function(o) {
    var attribute, escape, parts, values;

    if ((o == null) || typeof o !== 'object') {
      return '';
    }
    parts = (function() {
      var _ref, _results;

      _results = [];
      for (attribute in o) {
        escape = attribute === 'content' ? "'" : '';
        values = ((_ref = o[attribute]) != null ? _ref.constructor : void 0) === Array ? o[attribute].join(' ') : o[attribute];
        _results.push("" + attribute + ": " + escape + values + escape + ";");
      }
      return _results;
    })();
    if (parts.length > 0) {
      return '{ ' + parts.join('\n') + ' }';
    } else {
      return null;
    }
  };

  DocumentStyle.prototype.begin = true;

  DocumentStyle.prototype["import"] = function(file) {
    return this._import.push(file);
  };

  DocumentStyle.prototype.use = function(yourClassName) {
    var yourClass;

    yourClass = this._environments[yourClassName];
    if (yourClass && typeof yourClass === 'function') {
      return DocumentStyle.prototype.__extend__(this, new yourClass);
    } else {
      throw new Error("Couldn't find/use '" + yourClassName + "'");
    }
  };

  DocumentStyle.prototype.__add__ = function() {
    var args;

    args = Array.prototype.slice.call(arguments);
    return this._levels.push(args);
  };

  DocumentStyle.prototype.__addLine__ = function(line, addTrailingSemicolon) {
    return this.__add__(addTrailingSemicolon ? line.replace(/\;+\s*$/, ';') : line);
  };

  DocumentStyle.prototype.__add_environment__ = function(yourClass) {
    var className, _ref, _ref1;

    if (typeof yourClass === 'function') {
      className = (_ref = yourClass.toString()) != null ? (_ref1 = _ref.split('\n')) != null ? _ref1[0].replace(/^function\s(.+?)\(.*/, '$1') : void 0 : void 0;
      return this._environments[className] = yourClass;
    }
  };

  DocumentStyle.prototype.charset = function(charset) {
    if (charset) {
      return this.__addLine__("@charset '" + charset + "';");
    }
  };

  DocumentStyle.prototype.page = function(selector, values) {
    var _ref;

    _ref = DocumentStyle.prototype.seperate_selector_and_values(selector, values), selector = _ref.selector, values = _ref.values;
    if (values) {
      values = this.object_to_css(values);
    }
    if (selector) {
      return this.__addLine__("@page " + selector + " " + values);
    }
  };

  DocumentStyle.prototype.seperate_selector_and_values = function(selector, values) {
    if (typeof selector === 'object') {
      return {
        selector: '',
        values: selector
      };
    } else {
      if (selector == null) {
        selector = '';
      }
      return {
        selector: selector,
        values: values
      };
    }
  };

  DocumentStyle.prototype.font_face = function(query) {
    return this.__add__('@font-face', query);
  };

  DocumentStyle.prototype.media = function(query) {
    return this.__add__('@media', query);
  };

  return DocumentStyle;

})();

CSSS = (function() {
  CSSS.prototype.original = null;

  CSSS.prototype.source = null;

  CSSS.prototype.styletext = null;

  CSSS.prototype.coffeescript = null;

  CSSS.prototype.javascript = null;

  CSSS.prototype.context = null;

  CSSS.prototype.evaluated = null;

  CSSS.prototype.tree = {};

  CSSS.prototype.declarationPart = null;

  CSSS.prototype.seperateDeclarations = true;

  CSSS.prototype.attributesTypes = 'transform|filter|animation|animation-name|animation-duration|animation-timing-function|animation-delay|animation-iteration-count|animation-direction|animation-play-state|background|background-attachment|background-color|background-image|background-position|background-repeat|background-clip|background-origin|background-size|border|border-bottom|border-bottom-color|border-bottom-style|border-bottom-width|border-color|border-left|border-left-color|border-left-style|border-left-width|border-right|border-right-color|border-right-style|border-right-width|border-style|border-top|border-top-color|border-top-style|border-top-width|border-width|outline|outline-color|outline-style|outline-width|border-bottom-left-radius|border-bottom-right-radius|border-image|border-image-outset|border-image-repeat|border-image-slice|border-image-source|border-image-width|border-radius|border-top-left-radius|border-top-right-radius|box-decoration-break|box-shadow|overflow-x|overflow-y|overflow-style|rotation|rotation-point|color-profile|opacity|rendering-intent|bookmark-label|bookmark-level|bookmark-target|float-offset|hyphenate-after|hyphenate-before|hyphenate-character|hyphenate-lines|hyphenate-resource|hyphens|image-resolution|marks|string-set|height|max-height|max-width|min-height|min-width|width|box-align|box-direction|box-flex|box-flex-group|box-lines|box-ordinal-group|box-orient|box-pack|font|font-family|font-size|font-style|font-variant|font-weight|@font-face|font-size-adjust|font-stretch|content|counter-increment|counter-reset|quotes|crop|move-to|page-policy|grid-columns|grid-rows|target|target-name|target-new|target-position|alignment-adjust|alignment-baseline|baseline-shift|dominant-baseline|drop-initial-after-adjust|drop-initial-after-align|drop-initial-before-adjust|drop-initial-before-align|drop-initial-size|drop-initial-value|inline-box-align|line-stacking|line-stacking-ruby|line-stacking-shift|line-stacking-strategy|text-height|list-style|list-style-image|list-style-position|list-style-type|margin|margin-bottom|margin-left|margin-right|margin-top|marquee-direction|marquee-play-count|marquee-speed|marquee-style|column-count|column-fill|column-gap|column-rule|column-rule-color|column-rule-style|column-rule-width|column-span|column-width|columns|padding|padding-bottom|padding-left|padding-right|padding-top|fit|fit-position|image-orientation|page|size|bottom|clear|clip|cursor|display|float|left|overflow|position|right|top|visibility|z-index|orphans|page-break-after|page-break-before|page-break-inside|widows|ruby-align|ruby-overhang|ruby-position|ruby-span|mark|mark-after|mark-before|phonemes|rest|rest-after|rest-before|voice-balance|voice-duration|voice-pitch|voice-pitch-range|voice-rate|voice-stress|voice-volume|border-collapse|border-spacing|caption-side|empty-cells|table-layout|color|direction|letter-spacing|line-height|text-align|text-decoration|text-indent|text-transform|unicode-bidi|vertical-align|white-space|word-spacing|hanging-punctuation|punctuation-trim|text-align-last|text-justify|text-outline|text-overflow|text-shadow|text-wrap|word-break|word-wrap|2transform|transform-origin|transform-style|perspective|perspective-origin|backface-visibility|transition|transition-property|transition-duration|transition-timing-function|transition-delay|appearance|box-sizing|icon|nav-down|nav-index|nav-left|nav-right|nav-up|outline-offset|resize';

  CSSS.prototype.allAttributeTypes = function() {
    return "\\s+(\\-moz\\-|\\-ms\\-|mso\\-|\\-khtml\\-|\\-webkit\\-|\\-o\\-){0,1}(" + (this.attributesTypes.split('-').join('\\-')) + "){1}";
  };

  CSSS.prototype.pattern = {
    isInlineOperation: /\s+([a-zA-Z0-9\(]+[\(\)\%\/\*\+\-\.\s]*)+\s*$/,
    detectUnit: /[0-9]+(\.[0-9]+)*(in\b|cm\b|mm\b|em\b|ex\b|pt\b|pc\b|px\b|s\b|\%)/,
    isLineSelector: /^[a-z\.\#\&\*]+[a-z0-9\,\s\#\*\:\>\[\]\=\~\+\.\(\)\-\"\']*$/i,
    isLineAttribute: /^(\s+)([a-zA-Z\-]+)(\:|\s){1}/,
    comments: function() {
      return /(#\s.*|\/\/.*)?\n/g;
    },
    isMediaQuery: /^(\@media)\s+(.*)$/,
    isCSSQuery: /^(@media|@font\_face|@charset|@document|@namespace|@supports|@page)\s+(.*)$/,
    isCSSValue: /^([0-9\.]+(in|cm|mm|em|ex|pt|pc|px|s|\%))$/,
    hasOperator: function() {
      return /\s[\+\-\/\*\%]{1}\s/g;
    },
    isNotParsableValue: /^([0-9]+(\.[0-9])*|\@*[a-zA-Z\_]+)$/,
    doesLineBeginWithAttribute: null,
    processPartsSeperator: /\n@begin\n/,
    hasHyphenFunctionName: /(\s*)(@[a-z\_]+[a-z\_\-]+)/g,
    argumentIsString: /^\s*((\'.*\')|(\".*\"))\s*$/,
    cssColorValues: function() {
      return /\s(\#[a-z0-9]{3,6}|AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGray|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|Darkorange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGray|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGray|DimGrey|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gray|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGray|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGray|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGray|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\s*/ig;
    },
    variableWithUnit: function() {
      return /^(\@[a-zA-Z\_]+)\[(in|cm|mm|em|ex|pt|pc|px|s|\%)\]/g;
    }
  };

  function CSSS(original) {
    this.original = original != null ? original : null;
    this.context = new DocumentStyle;
  }

  CSSS.prototype.transformCssObjectsToJSON = function(s, options) {
    var css, currentWhiteSpacesCount, i, l, line, lineBeginsWithAttribute, lines, parsed, replace, whiteSpaces, whiteSpacesCount, _i, _len, _ref, _ref1;

    if (options == null) {
      options = {};
    }
    replace = options.replace;
    if (replace == null) {
      replace = true;
    }
    css = [];
    whiteSpacesCount = null;
    lines = s.split('\n');
    whiteSpaces = null;
    currentWhiteSpacesCount = null;
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      if (whiteSpaces == null) {
        whiteSpaces = (_ref = line.match(/^(\s+)/)) != null ? _ref[1] : void 0;
      }
      if (currentWhiteSpacesCount == null) {
        currentWhiteSpacesCount = (whiteSpaces != null ? whiteSpaces.length : void 0) || null;
      }
      lineBeginsWithAttribute = this.doesLineBeginsWithAttribute(line);
      if (currentWhiteSpacesCount > 0) {
        if (whiteSpacesCount !== currentWhiteSpacesCount || lineBeginsWithAttribute !== true) {
          css = [];
          if (whiteSpacesCount == null) {
            whiteSpacesCount = currentWhiteSpacesCount;
          }
          whiteSpaces = null;
        }
        if (lineBeginsWithAttribute) {
          if (whiteSpaces == null) {
            whiteSpaces = ((_ref1 = line.match(/^(\s+)/)) != null ? _ref1[1] : void 0) || '';
          }
          if (css.length === 0) {
            l = whiteSpaces + "o = \n";
            whiteSpaces += '  ';
            whiteSpacesCount = currentWhiteSpacesCount = whiteSpacesCount + 2;
            lines[i] = l + this.parseAttributeLine(line, {
              indent: whiteSpaces,
              escape: true
            });
            css.push(parsed);
          } else {
            whiteSpacesCount = currentWhiteSpacesCount;
            parsed = this.parseAttributeLine(line, {
              indent: whiteSpaces,
              escape: true
            });
            if (replace) {
              lines[i] = parsed;
            }
            if (lineBeginsWithAttribute) {
              css.push(parsed);
            }
          }
        }
      }
    }
    if (replace) {
      return lines.join('\n');
    } else {
      return css;
    }
  };

  CSSS.prototype.escapeCSSValue = function(s) {
    return s != null ? s.replace(/\'/g, "\\'") : void 0;
  };

  CSSS.prototype.operateInline = function(s, options) {
    var enclose, escape, hasOperators, onlyIfOperatorsExists, unit, withUnit, _ref;

    if (options == null) {
      options = {};
    }
    onlyIfOperatorsExists = options.onlyIfOperatorsExists, enclose = options.enclose, escape = options.escape, withUnit = options.withUnit;
    if (escape == null) {
      escape = false;
    }
    if (withUnit == null) {
      withUnit = false;
    }
    if (s) {
      s = String(s).trim(s);
      if (/^\'.*\'$/.test(s) || /^\".*\"$/.test(s) && !escape) {
        return s;
      }
      if (/^[0-9]+(\.[0-9]+)*$/.test(s) || /^\s*(@[a-zA-Z\_]+(\(.*?\))*\s*)+$/.test(s)) {
        if (enclose == null) {
          enclose = false;
        }
      }
      if (enclose == null) {
        enclose = true;
      }
      if (this.pattern.isCSSValue.test(s)) {
        if (onlyIfOperatorsExists == null) {
          onlyIfOperatorsExists = false;
        }
      }
      if (onlyIfOperatorsExists == null) {
        onlyIfOperatorsExists = true;
      }
      hasOperators = this.pattern.hasOperator().test(s);
      if (this.pattern.variableWithUnit().test(s)) {
        escape = enclose = false;
        unit = s.match(/\[(in|cm|mm|em|ex|pt|pc|px|s|\%)\]/i)[1];
        s = s.split("[" + unit + "]").join('') + (" , '" + unit + "'");
        s = "( new @__cssvalue__( " + s + " ).valueOf() )";
      }
      if (!hasOperators && /(@[a-zA-Z\_]+(\[[a-zA-Z0-9\_]+\])*(\(.*?\)))*/.test(s)) {
        if (enclose == null) {
          enclose = true;
        }
        if (enclose) {
          if (escape) {
            s = this.escapeCSSValue(s);
          }
          s = "'" + s + "'";
          return s.replace(/(@[a-zA-Z\_]+)(\[[a-zA-Z0-9\_]+\])*(\(.*?\))*/g, "' + $1$2$3 + '");
        }
      }
      if (onlyIfOperatorsExists && !hasOperators) {
        if (escape) {
          s = this.escapeCSSValue(s);
        }
        if (enclose) {
          return "'" + (s.replace(/(\s@[a-zA-Z]+)(\[[a-zA-Z0-9\_]+\])*(\(.*?\))*\s/g, "' + $1$2$3 + '")) + "'";
        } else {
          return "" + s;
        }
      }
      if (/^(\'.*\'|\".*\")$/.test(s)) {
        return s;
      }
      unit = ((_ref = s.match(this.pattern.detectUnit)) != null ? _ref[2] : void 0) || null;
      if (unit) {
        s = "( new @__cssvalue__( " + (s.split(unit).join('')) + " , '" + unit + "' )" + (withUnit ? '.toString()' : '') + " )";
      } else {
        s = "( new @__cssvalue__( " + (s.split(unit).join('')) + " )" + (withUnit ? '.toString()' : '') + " )";
      }
    } else {
      s = '';
    }
    return s;
  };

  CSSS.prototype.seperateDeclarationAndStyle = function() {
    var declarationPart, declarationsEnds, found, line, setBeginIfNotFound, splitPattern, styletext, useMediaQueryAsSeperator, _i, _len, _ref, _ref1;

    this.source = '';
    this.declarationPart = '';
    styletext = '';
    declarationPart = '';
    setBeginIfNotFound = '@begin';
    this.original = '\n' + this.original;
    useMediaQueryAsSeperator = true;
    splitPattern = this.pattern.processPartsSeperator;
    found = this.original.match(splitPattern);
    if (!found && useMediaQueryAsSeperator) {
      this.original = this.original.replace(/\n@media\s/, "\n" + setBeginIfNotFound + "\n@media ");
      found = this.original.match(splitPattern);
    }
    if (found) {
      _ref = this.original.split(splitPattern), declarationPart = _ref[0], styletext = _ref[1];
      styletext = ("\n" + found[0] + "\n") + styletext;
    } else {
      declarationsEnds = null;
      _ref1 = this.original.split('\n');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        if (this.pattern.isLineSelector.test(line) || this.pattern.isMediaQuery.test(line)) {
          declarationsEnds = true;
        }
        if (!declarationsEnds) {
          declarationPart += '\n' + line;
        } else {
          styletext += '\n' + line;
        }
      }
    }
    this.styletext = styletext;
    return this.declarationPart = declarationPart;
  };

  CSSS.prototype.processDeclaration = function() {
    var declarationPart, i, line, parts;

    this.declarationPart = this.transformCssObjectsToJSON(this.declarationPart, {
      replace: true
    });
    declarationPart = (function() {
      var _i, _len, _ref, _ref1, _results;

      _ref = this.declarationPart.split('\n');
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        line = _ref[i];
        line = this.renameHyphenFunctionName(line);
        if (!/(\'.*\')|(\".*\")/.test(line)) {
          line = line.replace(this.pattern.cssColorValues(), " '$1' ");
        }
        this.renameHyphenFunctionName(line);
        if (this.pattern.isInlineOperation.test(line)) {
          parts = line.match(/^(\s*)(.*?\=\s*)(.*)$/, line);
          if (parts != null ? parts[3] : void 0) {
            line = parts[1] + parts[2] + this.operateInline(parts[3], {
              enclose: false
            });
          } else {
            line = ((_ref1 = line.match(/^\s*/)) != null ? _ref1[0] : void 0) + this.operateInline(line, {
              enclose: false
            });
          }
        }
        _results.push(line);
      }
      return _results;
    }).call(this);
    return this.declarationPart = declarationPart.join('\n').trim();
  };

  CSSS.prototype.doesLineBeginsWithAttribute = function(line) {
    var regex, regexString;

    if (this.pattern.doesLineBeginWithAttribute) {
      regex = this.pattern.doesLineBeginWithAttribute;
    } else {
      regexString = "^" + (this.allAttributeTypes()) + "([\\s\\:]{1}.*)*$";
      regex = this.pattern.doesLineBeginWithAttribute = new RegExp(regexString, 'i');
    }
    return regex.test(line);
  };

  CSSS.prototype.doesLineHaveOnlyAttribute = function(line) {
    return new RegExp("^" + (this.allAttributeTypes()) + "\\:*\\s*$", 'i').test(line);
  };

  CSSS.prototype.renameHyphenFunctionName = function(line, replaceHyphenWith) {
    var match, name, newName;

    if (replaceHyphenWith == null) {
      replaceHyphenWith = '_';
    }
    if (this.pattern.hasHyphenFunctionName.test(line)) {
      match = line.match(this.pattern.hasHyphenFunctionName);
      if (match[0]) {
        name = match[0];
        newName = name.replace(/\-+/g, replaceHyphenWith);
        line = line.split(name).join(newName);
      }
    }
    return line;
  };

  CSSS.prototype._indentSpacesOfLine = function(line) {
    var _ref;

    return ((_ref = line.match(/^\s+/)) != null ? _ref[0].length : void 0) || 0;
  };

  CSSS.prototype.processStyleText = function() {
    var changedLine, i, indentSpacesCount, isInListedValues, lastLineWithSelector, lastSelectorLine, line, lineBefore, lineBeginsWithAttribute, lines, matches, nextLine, onlyAttribute, originalLines, styletext, whitespaces, _i, _len;

    styletext = this.styletext;
    lines = styletext.split('\n');
    originalLines = styletext.split('\n');
    lastSelectorLine = null;
    isInListedValues = null;
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      lineBeginsWithAttribute = this.doesLineBeginsWithAttribute(line);
      line = this.renameHyphenFunctionName(line);
      indentSpacesCount = this._indentSpacesOfLine(line);
      lineBefore = originalLines[i - 1] || '';
      nextLine = originalLines[i + 1] || null;
      lastLineWithSelector = lines[lastSelectorLine];
      if (this.pattern.isCSSQuery.test(line)) {
        matches = line.match(this.pattern.isCSSQuery);
        if (matches != null ? matches[2] : void 0) {
          line = "" + matches[1] + " " + (this.operateInline(matches[2]));
        }
      } else if (lineBeginsWithAttribute) {
        onlyAttribute = this.doesLineHaveOnlyAttribute(line);
        line = this.parseAttributeLine(line, {
          indent: line.match(/^\s+/)[0],
          escape: true
        });
        if (onlyAttribute) {
          line += ' [';
          isInListedValues = true;
        }
      } else if (isInListedValues) {
        whitespaces = Array(indentSpacesCount + 1).join(' ');
        line = whitespaces + this.operateInline(line, {
          whitespaces: whitespaces
        });
        if (!nextLine || (this._indentSpacesOfLine(nextLine) < indentSpacesCount)) {
          line += ' ]';
          isInListedValues = false;
        }
      } else {
        line = line.replace(/^(\s+)(\@[a-zA-Z]+\(.*\))/g, '\n$1$2');
        line = line.replace(/^(\s*)([a-zA-Z\.\#\&\>\:\*]+((?!\:\s).)*)$/, "\n@__add__ '$2', '$1', ");
        line = line.replace(/\n(\s*)([a-zA-Z\.\#\&\>\:\*]+((?!\:\s).)*)(\s*)$/, "\n@__add__ '$2', '$1', $4");
        lastSelectorLine = null;
      }
      if (lastLineWithSelector && lineBeginsWithAttribute && /^\s*(@[a-z\_\-]+)([^\,]\s*)*\s*$/i.test(lastLineWithSelector)) {
        matches = lastLineWithSelector.match(/^(\s*)(@[a-z\_\-]+)([^a-z\_\,].*)*\s*$/i);
        changedLine = matches[1] + matches[2];
        lines[lastSelectorLine] = changedLine += (matches[3] ? matches[3] + ',' : '') + ' __$cssAttributes__ =';
      }
      if (/^@[a-zA-Z\_\-]+/.test(line)) {
        lastSelectorLine = i;
      }
      lines[i] = line;
    }
    this.styletext = lines.join('\n').replace(/\n+/g, "\n");
    return this.styletext = this.styletext.replace(/(\n@__add__\s.+?)(\,\s[\n])(@__add__\s)/g, '$1\n$3');
  };

  CSSS.prototype.parse = function(s) {
    if (s) {
      this.original = s;
    }
    if (this.original) {
      this.original += '\n';
      this.original = this.original.replace(this.pattern.comments(), '\n').replace(/\n{3,}/g, '\n\n');
      if (this.seperateDeclarations) {
        this.seperateDeclarationAndStyle();
      }
      this.processDeclaration();
      this.styletext = '\n' + this.cleanup(this.styletext);
      this.processStyleText();
      this.source = this.declarationPart + '\n\n' + this.styletext.trim();
      this.source = this.source.trim();
      return this.compile();
    }
  };

  CSSS.prototype.parseAttributeLine = function(line, options) {
    var attr, indent, m, value, _ref;

    if (options == null) {
      options = {};
    }
    indent = options.indent;
    if (indent == null) {
      indent = line.match(/^(\s+)/)[1] || '';
    }
    m = line.match(/^(\s+)([a-zA-Z\-]+)(\:|\s){1}\s*(.+)$/);
    value = m != null ? (_ref = m[4]) != null ? _ref.trim() : void 0 : void 0;
    attr = m != null ? m[2] : void 0;
    if (value) {
      if (!/^\'.*\'$/.test(value)) {
        options.withUnit = true;
        value = this.operateInline(value, options);
        value = value.replace(/\+\'\)$/, ')');
        value = this.parseInlineArguments(value);
      }
      return "" + indent + "'" + attr + "': " + value;
    } else {
      return line.replace(/^(\s+)([a-zA-Z\-\_]+)\:*/, "" + indent + "'$2':");
    }
  };

  CSSS.prototype.parseInlineArguments = function(line) {
    var argument, method, methodsFound, parts, value, _i, _len;

    methodsFound = line.match(/@[a-zA-Z\_]+\(.+\)/g);
    if (methodsFound) {
      for (_i = 0, _len = methodsFound.length; _i < _len; _i++) {
        method = methodsFound[_i];
        parts = method.match(/^(@[a-zA-Z\_]+)\(([a-zA-Z0-9\%]+)\)/);
        if (parts != null ? parts[2] : void 0) {
          value = parts[2];
          argument = this.pattern.isNotParsableValue.test(value) ? value : this.operateInline(value, {
            enclose: false
          });
          line = line.split(parts[0]).join(parts[1] + ("(" + argument + ")"));
        }
      }
    }
    return line;
  };

  CSSS.prototype.compile = function() {
    this.declarationPart = null;
    if (typeof CoffeeScript === "undefined" || CoffeeScript === null) {
      throw 'CoffeeScript is needed';
    }
    this.javascript = CoffeeScript.compile(this.source);
    this.coffeescript = '\n\n  ' + this.source.split('\n').join('\n  ') + '\n\n';
    return this.source;
  };

  CSSS.prototype["eval"] = function() {
    if (this.context == null) {
      this.createContext();
    }
    if (this.context) {
      if (window) {
        CoffeeScript.__csss_context = this.context;
      }
      this.coffeescript = "doc = CoffeeScript.__csss_context || this\nrgba = (colors...) -> 'rgba('+colors.join(\", \")+')'\nrgb  = -> 'rgb('+Array.prototype.slice.call(arguments).join(\", \")+')'\ndoc.__init__()\ndoc.__eval__ = ->\n  " + this.coffeescript + "\ndoc.__eval__()\ndoc";
      return this.evaluated = CoffeeScript["eval"](this.coffeescript);
    } else {
      return CoffeeScript["eval"](this.coffeescript, {
        sandbox: this.context
      });
    }
  };

  CSSS.prototype.cleanup = function(s) {
    s = "\n" + s.replace(/\n+/g, "\n");
    s = s.replace(/\;[^\S\n]*/g, ''.replace(/\t/g, '  '));
    return s.trim();
  };

  CSSS.prototype.use = function(MyEnvironmentClass) {
    return this.context.__add_environment__(MyEnvironmentClass);
  };

  CSSS.prototype.error = function(e) {
    var _ref;

    if (e != null) {
      this._error = e;
    }
    return ((_ref = this._error) != null ? _ref.message : void 0) || this._error || null;
  };

  CSSS.prototype.css = function() {
    var before, cssString, i, insideParts, isNormalSelector, isReference, level, levelBefore, levels, mediaQuery, parts, s, section, selector, selectorBefore, selectorString, values, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _s;

    levels = {};
    cssString = '';
    levelBefore = null;
    selectorBefore = '';
    mediaQuery = null;
    this.evaluated = null;
    this["eval"]();
    if (!(((_ref = this.evaluated) != null ? (_ref1 = _ref._levels) != null ? _ref1.length : void 0 : void 0) > 0)) {
      return '';
    }
    _ref2 = this.evaluated._levels;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      section = _ref2[_i];
      if (section.length === 1) {
        cssString += section[0];
      } else if (section[0] === '@media') {
        if (mediaQuery) {
          cssString += ' } ';
        }
        cssString += "\n@media " + section[1] + " {";
        mediaQuery = section[1];
      } else if (section[0] === '@font-face') {
        cssString += "\nfont-face: " + (DocumentStyle.prototype.object_to_css(section[1])) + "\n";
      } else {
        selector = selectorString = section[0];
        level = Math.floor(section[1].length / 2);
        values = DocumentStyle.prototype.object_to_css(section[2]);
        isReference = selectorString[0] === '&';
        isNormalSelector = /^[\.\#\:]{1}/.test(selectorString.trim());
        if (section.length > 2) {
          for (i = _j = 3, _ref3 = section.length; 3 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 3 <= _ref3 ? ++_j : --_j) {
            DocumentStyle.prototype.__extend__(section[2], section[i]);
          }
        }
        if (level < levelBefore && (levels != null ? levels[level - 1] : void 0)) {
          before = ((_ref4 = levels[level - 1]) != null ? _ref4.trim() : void 0) || '';
          selectorString = levels[level - 1].trim() + (isReference ? selectorString.trim().substring(1) : isNormalSelector ? selectorString : ' ' + selectorString);
        } else if (level >= levelBefore) {
          if (isReference) {
            parts = (function() {
              var _k, _len1, _ref5, _results;

              _ref5 = selectorString.substring(1).split(',');
              _results = [];
              for (_k = 0, _len1 = _ref5.length; _k < _len1; _k++) {
                s = _ref5[_k];
                if (/^[a-z]+/.test(s)) {
                  s = ' ' + s;
                }
                insideParts = (function() {
                  var _l, _len2, _ref6, _results1;

                  _ref6 = levels[level - 1].trim().split(',');
                  _results1 = [];
                  for (_l = 0, _len2 = _ref6.length; _l < _len2; _l++) {
                    _s = _ref6[_l];
                    if (_s != null ? _s.trim() : void 0) {
                      _results1.push(_s.trim() + s.replace(/\s([^a-zA-Z])/g, '$1').replace(/\s([a-zA-Z]+.+)/g, ' $1'));
                    } else {
                      _results1.push(void 0);
                    }
                  }
                  return _results1;
                })();
                _results.push(insideParts.join(', ').replace(/\,\s$/, ''));
              }
              return _results;
            })();
            selectorString = parts.join(', ').replace(/\,\s$/, '');
          } else {
            before = (_ref5 = levels[level - 1]) != null ? _ref5.trim() : void 0;
            selectorString = selectorString.trim();
            if (!isNormalSelector) {
              selectorString = ' ' + selectorString;
            }
            selectorString = (before || '') + ' ' + selectorString.trim();
          }
        }
        if (values) {
          cssString += "\n" + selectorString + " " + (DocumentStyle.prototype.object_to_css(section[2]));
        }
        if (level !== levelBefore) {
          levelBefore = level;
          selectorBefore = selectorString;
        }
        levels[level] = selectorString;
      }
    }
    if (mediaQuery) {
      cssString += " } ";
    }
    return cssString;
  };

  return CSSS;

})();

if (window) {
  if ((_ref = window.CSSS) == null) {
    window.CSSS = CSSS;
  }
} else {
  exports = CSSS;
}
